# Array 배열
* 같은 형의 데이터 타입을 메모리에 저장하는 선형적 자료구조.
  - 선형자료구조: 내 앞 데이터 하나 뒷 데이터 하나 1:1
* 논리적 구조와 물리적 구조가 동일 (물리적으로도 옆 논리적으로 도 옆)
fixed-length 로 시작. 인덱스 연산. n~ n-1개 까지
인덱스 연산 가능.
연속적 자료구조 중간 값이 빌수 없음. insert / delete 연산이 배열의 갯수에 종속 O(n)
* 배열을 구현한 ArrayList / Vector
- vector 동기화 구현. (lock 이 걸림)

# Linked List 데이터와 링크로 구성
* 배열의 단점을 보완.
* 1개의 노드가 자신의 값과 자기 자신 다음 주소값을 가지고 있음.
* 물리적 위지와 논리적 위치가 같지 않음.
* insert / delete 연산이 배열보다 적음. 삭제나 삽입시 실제 위치가 변경되는게 아니라 노드의 다음 주속값이 변경.
* 인덱스 연산이 배열만큼 편하지 않음. 몇 번째 요소를 찾기 위해 첫 노드 부터 시작.

# Stack & Queue
* 데이터의 추가삭제는 앞에서 부터 일어남.
* 선형자료 구조.
* LIFO / FIFO
* 스텍 : 가장 최근에 일어난 정보를 참조할 때 사용. ex) 멀리건, 왔던길 되돌아 가기
* 큐 : 대기열

# Tree
* 대칭이 있는 자료구조.
* 자식노드가 최대 2개인 Tree 를 2진 트리라고 함. BST (Binaly search tree)
 - 유일한 키 값.
 - 루트 노드의 키 값 기준
* left child 는 부모값보다 작은값. 오른쪽 자식값은 부모보다 큰값. 중복 없음.1개
23, 10, 48, 15, 7, 22, 56
          23
       10    48
      7  15     56
           22
* 검색의 속도를 높이기 위해 트리 사용 long2n but 트리의 발란스가 안 맞으면 O(n)
1,2,3,4,5
 1
   2
     3
       4
         5

* in-oder sorting 오름차순 정렬
left - 나 - right. 7,10,15,22,23,48,56

# 해싱
* 검색을 위한 자료구조. ex) 좌석 배치
* 충돌을 방지.
* 검색속도 O(1) 빨름.


